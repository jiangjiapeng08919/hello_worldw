1、pwm：50hz      A0

```
mian之前：
Timer_A_PWMConfig TIM0_PwmConfig =
        {
           TIMER_A_CLOCKSOURCE_SMCLK,             //3M Hz
           TIMER_A_CLOCKSOURCE_DIVIDER_4,         //4分频
           15000,                                 //ARR
           TIMER_A_CAPTURECOMPARE_REGISTER_1,     //捕获比较寄存器1
           TIMER_A_OUTPUTMODE_RESET_SET,
           1200,                                  //CCR
        };      
void TimerA0_Init(void)       
{
    GPIO_setAsPeripheralModuleFunctionOutputPin(GPIO_PORT_P2,GPIO_PIN4,GPIO_PRIMARY_MODULE_FUNCTION);
    Timer_A_generatePWM(TIMER_A0_BASE, &TIM0_PwmConfig);
}
```

pwm配置：

```
main之后，while之前：
                   TimerA0_Init(); 
while里面：
                   TIMER_A_CMSIS(TIMER_A0_BASE)->CCR[1] = 1200;
```

2、定时器中断：A3

```
mian之前：
void TIMERA3_IRQHandler(void)
{
    Timer_A_clearInterruptFlag(TIMER_A3_BASE);
    /*
    处理函数
    */
}
void TimerIntuerruptInit(double period)
{
    Timer_A_UpModeConfig Timer=
            {
              TIMER_A_CLOCKSOURCE_SMCLK,
              TIMER_A_CLOCKSOURCE_DIVIDER_48,
              (int)(period/1000*62500),
              TIMER_A_TAIE_INTERRUPT_ENABLE,
            };
    Timer_A_configureUpMode(TIMER_A3_BASE,&Timer);
    Timer_A_enableInterrupt(TIMER_A3_BASE);
    Timer_A_clearInterruptFlag(TIMER_A3_BASE);
    Interrupt_enableInterrupt(INT_TA3_N);
    Interrupt_enableMaster();
    Interrupt_registerInterrupt(INT_TA3_N, TIMERA3_IRQHandler);
    Timer_A_startCounter(TIMER_A3_BASE, TIMER_A_UP_MODE);
}
```

时间配置:

```
mian之后，while之前：
                    TimerIntuerruptInit(1000);//1000ms
```

3、串口重定向（串口配置）：   A2

```
mian之前：
int UART_printf(uint32_t moduleInstance, const char *fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    int length;
    char buffer[128];
    length = vsnprintf(buffer, 128, fmt, ap);
    for (int i = 0; i < length; i++)
        UART_transmitData(moduleInstance, *(buffer + i));
    va_end(ap);
    return length;
}

void UartRetargetInit(void)
{
    const eUSCI_UART_ConfigV1 uartConfig =
            {
                    EUSCI_A_UART_CLOCKSOURCE_SMCLK,          // SMCLK Clock Source
                    6,                                      // BRDIV
                    8,                                       // UCxBRF
                    32,                                      // UCxBRS
                    EUSCI_A_UART_NO_PARITY,                  // No Parity
                    EUSCI_A_UART_LSB_FIRST,                  // LSB First
                    EUSCI_A_UART_ONE_STOP_BIT,               // One stop bit
                    EUSCI_A_UART_MODE,                       // UART mode
                    EUSCI_A_UART_OVERSAMPLING_BAUDRATE_GENERATION,  // Oversampling
                    EUSCI_A_UART_8_BIT_LEN                  // 8 bit data length
            };

    MAP_GPIO_setAsPeripheralModuleFunctionInputPin(GPIO_PORT_P3,GPIO_PIN2 | GPIO_PIN3, GPIO_PRIMARY_MODULE_FUNCTION);
    CS_setDCOCenteredFrequency(CS_DCO_FREQUENCY_12);
    //CS_setDCOFrequency(12000000);
    //CS_initClockSignal(CS_SMCLK,CS_DCOCLK_SELECT,CS_CLOCK_DIVIDER_1);
    MAP_UART_initModule(EUSCI_A2_BASE, &uartConfig);
    MAP_UART_enableModule(EUSCI_A2_BASE);
    MAP_UART_enableInterrupt(EUSCI_A2_BASE, EUSCI_A_UART_RECEIVE_INTERRUPT);
    MAP_Interrupt_enableInterrupt(INT_EUSCIA2);
}
```

4、编码器：

```
void Encoder_IRQHandler_r(void)
{
    uint8_t temp = GPIO_getInputPinValue(GPIO_PORT_P4, GPIO_PIN1);
    uint32_t status;
    status = MAP_GPIO_getEnabledInterruptStatus(GPIO_PORT_P4);
    MAP_GPIO_clearInterruptFlag(GPIO_PORT_P4, status);
    if (status & GPIO_PIN6)
    {
        if (temp == GPIO_INPUT_PIN_HIGH)
        {
            CNT1++;
        } else if (temp == GPIO_INPUT_PIN_LOW)
        {
            CNT1--;
        }
    }
}

void Encoder_IRQHandler_l(void)
{
    uint8_t temp = GPIO_getInputPinValue(GPIO_PORT_P5, GPIO_PIN0);
    uint32_t status;
    status = MAP_GPIO_getEnabledInterruptStatus(GPIO_PORT_P5);
    MAP_GPIO_clearInterruptFlag(GPIO_PORT_P5, status);
    if (status & GPIO_PIN1)
    {
        if (temp == GPIO_INPUT_PIN_HIGH)
        {
            CNT2++;
        } else if (temp == GPIO_INPUT_PIN_LOW)
        {
            CNT2--;
        }
    }
}
```

```
void EncoderInit_r(void)
{
    GPIO_setAsInputPinWithPullUpResistor(GPIO_PORT_P4, GPIO_PIN6);
    GPIO_setAsInputPinWithPullUpResistor(GPIO_PORT_P4, GPIO_PIN1);
    GPIO_clearInterruptFlag(GPIO_PORT_P4, GPIO_PIN6);
    GPIO_enableInterrupt(GPIO_PORT_P4, GPIO_PIN6);
    GPIO_interruptEdgeSelect(GPIO_PORT_P4, GPIO_PIN6, GPIO_LOW_TO_HIGH_TRANSITION);
    Interrupt_enableInterrupt(INT_PORT4);
    Interrupt_enableMaster();
    Interrupt_registerInterrupt(INT_PORT4, Encoder_IRQHandler_r);
}
void EncoderInit_l(void)
{
    GPIO_setAsInputPinWithPullUpResistor(GPIO_PORT_P5, GPIO_PIN1);
    GPIO_setAsInputPinWithPullUpResistor(GPIO_PORT_P5, GPIO_PIN0);
    GPIO_clearInterruptFlag(GPIO_PORT_P5, GPIO_PIN1);
    GPIO_enableInterrupt(GPIO_PORT_P5, GPIO_PIN1);
    GPIO_interruptEdgeSelect(GPIO_PORT_P5, GPIO_PIN1, GPIO_LOW_TO_HIGH_TRANSITION);
    Interrupt_enableInterrupt(INT_PORT5);
    Interrupt_enableMaster();
    Interrupt_registerInterrupt(INT_PORT5, Encoder_IRQHandler_l);
}
```

在定时器10ms中处理：

float v_Left;
float v_Right;
uint32_t CNT1;
uint32_t CNT2;
uint32_t capturenumber1_Left=0;
uint32_t capturenumber2_Left=0;
uint32_t capturenumber1_Right=0;
uint32_t capturenumber2_Right=0;

```
 capturenumber2_Right=CNT1;
 capturenumber2_Left=CNT2;
 v_Right=(float)(((capturenumber2_Right-capturenumber1_Right)*1.0/15000.0*100));
 v_Left=(float)(((capturenumber2_Left-capturenumber1_Left)*1.0/15000.0*100));
 capturenumber1_Right=capturenumber2_Right;
 capturenumber1_Left=capturenumber2_Left;
```
